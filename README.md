# my-studies
Şimdi, bu kursta üzerinde çalışacağımız uygulamaya derin bir dalış yapalım. Bildiğiniz gibi, bu kurs bir yazılım geliştirme ekibinde kullanacağınız süreçlere ve uygulamalara odaklanacaktır. Odağımız gerçekten uygulamanın kendisi değil. Yüksek kaliteli yazılımı kullanıcıların önüne çıkarmak ve uygulamanın mümkün olan en iyi kullanılabilirliğini veya çalışma süresini elde etmek için atılması gereken adımlara daha fazla odaklanacağız. Ama evet, bir uygulamamız var. Bir tane oluşturduk, böylece gerçek dünyaya yakın bir uygulama ile pratik yapabiliriz. Uygulamayı görelim. Uygulama ana sayfasından Yeni oyun oluştur'a tıklayabilirim. Şimdi oyuna katılmak isteyen herkesle paylaşabileceğim bir bağlantı ile karşınızdayım. Ve sağ tarafta, oyuncu adım olarak rastgele bir renk görüyorum. Bağlantıyı diğer oyuncularla paylaşabilirim.

Bu oyuncular oyuna katılmak için bir düğme görür. Oyuna katıl'ı tıklayabilirler,

ve sağ tarafta güncellenmiş oyuncu listesini görüyoruz. İlk oyuncunun ekranına geri dönerek, Oyunu başlat'a tıklıyorum ve şimdi trivia sorularıyla karşılaşıyoruz.

Listedeki bir cevaba tıklayabilirim ve süre bittiğinde sağ tarafta puanların güncellendiğini görüyorum.

Oyun herkese 10 soru veriyor, ardından hepimize ekran üzerinden bir oyun gösteriyor. Bir saniye duraklayın ve böyle bir uygulamayı nasıl tasarlayacağınızı düşünün. Benzer çözümlere ulaşıp ulaşamayacağımızı görmek ilginç olurdu. Fikirlerinizi tartışma forumlarında paylaşmaktan çekinmeyin.

Bu uygulama için kullandığımız mimariden bahsedelim. Bu konuşmayı yeni bir projedeki ilk gününüz gibi düşünün. Bu uygulamayı oluşturmak ve barındırmak için kullanılan tüm teknolojilere aşina olmayabilirsiniz, ancak bunun sizi endişelendirmesine izin vermeyin, ilerledikçe birçok teknolojiyi açıklayacağız. Kodun tamamı verilir. Ve unutmayın, buradaki odak noktamız süreçler ve uygulamalar olacak. Ön yüzle başlayalım. Web uygulaması, bir Amazon Simple Storage Service veya S3 kovasından sunulan bir React ön ucudur.

Bu uygulama için S3, web sunucumuz olarak görev yapmaktadır. Uygulamanın arka ucunu barındırmak için birkaç altyapı kaynağı oluşturuyoruz. Ön uç, bir API Ağ Geçidi tarafından barındırılan WebSockets API'si ile iletişim kurar. API Gateway, uygulamanın API'sini barındıracağımız tam olarak yönetilen bir hizmettir. Yeni oyun oluştur'a tıkladığınızda, tarayıcıdan WebSockets API'sine bir WebSocket mesajı gidiyor. Arka uç işlem kaynakları Lambda işlevlerinde barındırılır. Lambda, sunucuları tedarik etmek veya yönetmek zorunda kalmadan işlev kodumuzu çağırabildiğimiz sunucusuz bir bilgi işlem hizmetidir. Oyunlar oluşturmak, katılmak ve başlatmak için kullanılan altı Lambda işlevine ve ayrıca oyunculara soru göndermek, yanıtları kabul etmek ve puanları hesaplamak için mantığa sahibiz. Uygulamamız için verileri nerede saklayacağız? Bunun için bir Amazon DynamoDB tablosu kullanacağız. DynamoDB, tam olarak yönetilen bir anahtar/değer hizmeti ve belge veritabanıdır. Yeni bir oyun oluşturduğunuzda veya bir oyuna katıldığınızda, uygulama TriviaConnections tablosunda yeni bir öğe oluşturur. Bir soruyu yanıtladığınızda, uygulama yanıtı hatırlamak için öğenizi günceller. Bir oyuna başladık. Her bağlı oyuncu için TriviaConnections tablosunda satırlarımız var. Şimdi, çalışan oyunun durumunu izlememiz gerekiyor.

Oyuncular hangi soruları yanıtlamak için duraklıyor, oyuncu puanlarını güncellemek için bir duruma geçiyor? Bunun için bir AWS Step Functions durum makinesi kullanacağız.

Durum makinesinin beş durumu vardır. Bir oyun başlatıldığında, bir durum makinesi yürütmesini başlatır ve bir soru listesi içeren giriş verilerini iletiriz. Durum makinesi yürütmesi soru durumunda başlar. Bu, mevcut soruyu tüm oyunculara gönderen soru Lambda işlevini çağırır. Ardından, oyuncuların cevaplarını göndermelerine izin verirken bir bekleme durumuna giriyoruz. Ön uçta bir yanıta tıklamak, API'ye yanıt Lambda işlevini çağıran bir WebSocket mesajı gönderir. Lambda işlevi, DynamoDB öğesini oynatıcının yanıtıyla günceller.
 
Bekleme durumumuz tamamlanır ve puan durumuna geçilir, burada puan hesaplama işlevi DynamoDB tablosundaki yanıtlar üzerinde döner, puanları günceller ve puanları bağlı tüm oyunculara gönderir. Durum makinesi soru üzerinde döner, bekler ve sorularımız bitene kadar durumu puanlar. Şimdi, durum makinesi yürütmesinin tamamlandığı, durum üzerinden oyuna giriyoruz. AWS hizmetleri, API Gateway, S3, Lambda kullanıyoruz,

Genellikle, yazılım geliştirme yaparken ilk aklımıza gelen şey kod yazmaktır. Bir projeye katıldığınızda, ister yeni ister bir süredir devam eden bir proje olsun, amaç genellikle aynıdır. Proje yöneticileri, koda özellikler eklemek istiyor. Geliştiriciler de bu özellikleri hızlı, güvenli ve güvenilir bir şekilde kullanıcıların önüne çıkarmak istiyor. Amacı göz önünde bulundurulduğunda, genellikle dört sık sorulan soru vardır: Kod nerede? Güncellemeleri nerede teslim etmeliyim? Ne sıklıkla devirde bulunmalı ve entegre olmalıyım? Ve değişiklikler son kullanıcılar için ne zaman dağıtılır? Bu soruları cevaplamak için sözleşmelerle gelmek ekibe kalmış. Bu nedenle, cevaplar, ihtiyaçlarına bağlı olarak duruma göre değişir. Bunu söylüyorum, çünkü gereksinimleriniz veya ekibinizin kültürü farklı olabilir. Bu kursun bir parçası olarak, yanıtları kendi senaryonuzda bulabilmeniz için size fikir ve en iyi uygulamaları verebilecek, bunları yanıtlamak için bir yaklaşım izleyeceğiz. Ama unutmayın, nihayetinde, ihtiyaçlarınıza göre cevaplamak size kalmış. İlk sorudan başlayarak her soruyu tek tek almama izin verin: Kod nerede? Ekip olarak çalışıyorsanız ve değişikliklerinizi bir kod deposuna entegre etmek ve bu değişiklikleri diğer ekip üyelerine sunmak istiyorsanız, AWS CodeCommit iyi bir seçim olabilecek AWS tarafından yönetilen bir hizmettir. CodeCommit, tüm standart Git işlevlerinin desteklendiği özel Git depolarını barındıran yönetilen bir kaynak denetimi hizmetidir. Dolayısıyla Git depolarına aşinaysanız, AWS CodeCommit'e de aşina olacaksınız. AWS CodeCommit'te depo oluşturulduktan sonra bir git klonu yapabilir ve kodu geliştirme ortamınıza alabilirsiniz. Şu andan itibaren, CodeCommit'te barındırılan depoyla, kimlik doğrulaması yapmak ve kod tabanıyla şifreli bir şekilde etkileşim kurmak için bir AWS kimlik bilgisi kullanabilme avantajıyla güvenli bir şekilde etkileşime girebilirsiniz.

Şimdi ikinci soru: Kod güncellemelerimi nerede yapmalıyım? Bir ekibin parçası olarak çalışırken, sonunda birden fazla kişi aynı dosyalarda değişiklik gerektirebilecek özellikler üzerinde çalışacaktır. Bunun için en yaygın yaklaşım, bir branch stratejisine karar vermektir. Bu taahhütleri bir özellik branchine gönderebilirsiniz. Değişiklikler hazır olduğunda, kodun otomatik araçlarla değerlendirilip test edilebileceği ana branch ile birleştirme yaparak bunları entegre edebilirsiniz. Daha sonra branches stratejileri hakkında daha fazla konuşacağız. Ancak şubelerle çalışmak başka bir soruyu gündeme getiriyor: Ne sıklıkla taahhütte bulunmalı ve entegre olmalıyım? Düzenli olarak kod dağıtmanın bazı büyük avantajları var. Bir şeyleri CodeCommit'e aktardığınızda, iyi dayanıklılık seviyelerine sahip AWS Cloud'da depolanır. Ve dayanıklı olduğu için, dizüstü bilgisayarınız hasar görürse veya takside kaybolursa işiniz kaydedilir. Şimdi dördüncü soru: Değişiklikler ne zaman dağıtılır ve son kullanıcıların önüne çıkarılır? Tahmin edebileceğiniz gibi, cevap da düzenlidir. Kodu ne kadar sık ​​entegre edersek, testçiler tarafından hatalar o kadar erken tespit edilebilir. İşler test ortamlarına daha sık dağıtıldığında, testçiler, kodun beklenene göre davranıp davranmadığını hızla doğrulayabilir. Bir özelliğin devreye alınması için haftalarca beklemesi gerekiyorsa, potansiyel olarak ilk günden eski olan bir şeyi teslim edebiliriz. Birçok işletme için yeni özellikleri hızlı bir şekilde devreye almak çok önemlidir. Ve bu kursta göreceğiniz gibi, sürekli entegrasyon hattında otomasyona sahip olmak, bunun gerçekleşmesi için anahtardır. Russ şimdi AWS CodeCommit ile başlamanın ne kadar kolay olduğunu gösterecek. - [Russ] Konsolda CodeCommit'e bir göz atalım. CodeCommit'e gittim. Depo oluştur'a tıklayabilir ve yeni depoma bir ad verebilirim.
  Kimlik doğrulama ve erişim denetimi burada nasıl çalışır? IAM kullanıcımın kimliğini CodeCommit'te doğrularken üç seçeneğim var. IAM kullanıcım için Git kimlik bilgileri oluşturmasını IAM'den isteyebilirim. Oluşturulan kimlik bilgileri,  deponuza akıllı HTTPS Git protokolü üzerinden eriştiğinizde bir kullanıcı adı ve parola gibi kullanılabilir. IAM ayrıca bir SSH ortak anahtarını IAM kullanıcınızla ilişkilendirebilir. Bunu kullanarak kimlik doğrulaması yaptığınızda, Git SSH protokollerini kullandığımızda anahtarınızın özel bölümünü kullanırsınız. Son olarak, CodeCommit, kimlik doğrulama için imzalanmış kimlik bilgilerini destekler. CodeCommit uzak yardımcısını kullanırsanız bu çok kolay hale gelir. Remote helper dizüstü bilgisayarımda yüklü. Böylece, CodeCommit önekine sahip bir URL'den klonlayabilirim.  

Bu klonlandı. Bu, AWS CLI'min yapılandırıldığı kimliğin tamamen aynısını kullanıyor. Ayrıca, bu biçimi kullanarak bir Bölge veya bir CLI profiline referans içeren bir URL oluşturabilirim. AWS'de erişim denetimi için IAM politikalarımızı seviyoruz. CodeCommit, IAM kimliğinize eklenen politikanın erişim kontrolünü zorlar. Bu şekilde, bir kimliğin bir özellik dalına itilmesine izin veren, ancak örneğin bir ana dalla birleşmemize izin vermeyen bir politika oluşturabiliriz. Git ile her zaman çalıştığım gibi, bu depoyla etkileşim kurabilirim.  Bir main branch oluşturalım. Ve şimdi bir readme dosyası oluşturmak istiyorum.


Bu dosyayı Git dizinine ekleyebilirim. 

Ve create a commit.

Ve son olarak, push the commit. 

Konsola dönüp kodu tekrar görüntüleyerek,

şimdi kodu depoda görüyoruz. Commitlere tıklarsam, birkaç saniye önce oluşturduğum commiti görüyorum. Kodumun AWS altyapısı kullanılarak güvenli ve dayanıklı bir şekilde saklandığını bilerek artık geceleri biraz daha rahat uyuyabiliyorum. 